;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;START RULE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
[(define "brouhaha_main" (fixedparam []) body)
 -->
 (eval body {top-level-env} (halt))]




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EVAL CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;BASE PRIMITIVE TYPES
[(eval (quote dat) env kont)
 -->
 (store (addr (quote dat)) dat)
 (ret (addr (quote dat)) kont)]

;FUNCTION AND VARIABLE REFERENCES
[(eval (ref x) env kont)
 -->
 (ret {env-map env x} kont)]

;LAMBDA AND FUNC
[(eval e env kont)
 (= e (lambda _ _))
 -->
 (store (addr e) (clo e env))
 (ret (addr e) kont)]

;APP AND APPLY
[(eval (app ef [eas ...]) env kont)
 -->
 (eval ef env (appk [] eas env kont))]

[(eval (appl ef ea) env kont)
 -->
 (eval ef env (applak ea env kont))]

;IF CASE
[(eval (if guard tExp fExp) env kont)
 -->
 (eval guard env (if-k tExp fExp env kont))]

;LET CASE
[(eval (let [(binding lhs rhs) bind-rest ...] body) env kont)
 -->
 (eval rhs env (letk body [lhs] [] bind-rest env kont))]

;APPLY-PRIM CASE
[(= e (eval (apply-prim op lst) env kont))
 -->
 (store (saddr e) (state e))
 (ret (saddr e) kont)]

;PRIM CASE
[(= e (eval (prim op [lst ...]) env kont))
 -->
 (store (saddr e) (state e))
 (ret (saddr e) kont)]


;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RET CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;LAMBDA AND FUNC
[(ret a (appk [as ...] [ea0 ea-rest ...] env kont))
 -->
 (eval ea0 env (appk [as ... a] [ea-rest ...] env kont))]

[(ret a (appk [af as ...] [] env kont))
 (store af vf)
 -->
 (apply vf (fixedarg [as ... a]) kont)]

[(ret af (appk [] [] env kont))
 (store af vf)
 -->
 (apply vf (fixedarg []) kont)]

[(ret af (applak ea env kont))
 -->
 (eval ea env (applfk af kont))]

[(ret a (applfk af kont))
 (store af vf)
 -->
 (apply vf (vararg a) kont)]

[(ret a (kaddr eb))
 -->
 (ret a {store (kaddr eb)})]

;IF CASES
[(ret ga (if-k tExp fExp env kont))
 (store ga (bool "t"))
 --> 
 (eval tExp env kont)]

[(ret ga (if-k tExp fExp env kont))
 (store ga (bool "f"))
 --> 
 (eval fExp env kont)]

[(ret (saddr _) (if-k tExp fExp env kont))
 --> 
 (eval tExp env kont)
 (eval fExp env kont)]

;LET CASE
[(ret a (letk body [xs ...] [as ...] [(binding lhs rhs) bind-rest ...] env kont))
 -->
 (eval rhs env (letk body [xs ... lhs] [as ... a] bind-rest env kont))]

[(ret a (letk body [xs ...] [as ...] [] envlet kont))
 -->
 (store (kaddr body) kont)
 (do-fixed-prop-all xs [as ... a])
 (eval body {ext-all !(do-ext-all envlet xs)} (kaddr body))]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APPLY CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;DEFINE --> CLOSURE
[(apply (define fname params body) args kont)
 --> 
 (apply (clo (lambda params body) {top-level-env}) args kont)]


;FIXED ARG
[(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) (fixedarg [as ...]) kont)
 --> 
 (store (kaddr eb) kont)
 (do-fixed-prop-all xs as)
 (eval eb {ext-all !(do-ext-all envlam xs)} (kaddr eb))]

 [(apply (clo (lambda (varparam x) eb) envlam) (fixedarg [as ...]) kont)
 --> 
 (store (kaddr eb) kont)
 (store (addr x) (list-of as))
 (eval eb (env-set envlam x (addr x)) (kaddr eb))]


 ;VARIADIC ARG
[(apply (clo (lambda (varparam x) eb) envlam) (vararg a) kont)
 --> 
 (store (kaddr eb) kont)
 (store-flow a (addr x))
 (eval eb {ext-all !(do-ext-all envlam [x])} (kaddr eb))]

[(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) (vararg a) kont)
 (store a (list-of as))
 --> 
 (store (kaddr eb) kont)
 (do-var-prop-all xs as)
 (eval eb {ext-all !(do-ext-all envlam xs)} (kaddr eb))]



;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;HELPER FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;DO-EXT-ALL/EXT-ALL
[-->
 (ext-all ?(do-ext-all env [x x-rest ...])
          {ext-all !(do-ext-all (env-set env x (addr x)) x-rest)})]

(ext-all ?(do-ext-all env []) env)


;DO-VIXED-PROP-ALL
[(do-fixed-prop-all [x x-rest ...] [a a-rest ...])
 -->
 (do-fixed-prop-all x-rest a-rest)
 (store-flow a (addr x))]


;DO-VAR-PROP-ALL
[(do-var-prop-all [x x-rest ...] [a a-rest ...])
 -->
 (do-var-prop-all-h [x x-rest ...] [a a-rest ...] [a a-rest ...])]

[(do-var-prop-all-h [x x-rest ...] [a a-rest ...] a-old)
 -->
 (do-var-prop-all-h [x x-rest ...] a-rest a-old)
 (store-flow a (addr x))]


[(do-var-prop-all-h [x x-rest ...] [] a-old)
 -->
 (do-var-prop-all-h x-rest a-old a-old)]

;STORE-FLOW
[(store a v)
 (store-flow a a1)
 -->
 (store a1 v)]

;ENV HANDLING
(env-map ?(env-set env x addr) x addr)


[(=/= x y)
 (env-set _ y _)
 -->
 (env-map ?(env-set env x _) y {env-map env y})]


 (answer ?(ret (addr a) (halt)) {store (addr a)})
 (answer ?(ret (saddr a) (halt)) {store (saddr a)})

;----------------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APPENDED PROGRAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------------;
(store (addr "+") (define "+" (varparam "lst") (apply-prim "+" (ref "lst"))))
(store (addr "max") (define "max" (varparam "lst") (apply-prim "max" (ref "lst"))))
(store (addr "-") (define "-" (varparam "lst") (apply-prim "-" (ref "lst"))))
(store (addr "*") (define "*" (varparam "lst") (apply-prim "*" (ref "lst"))))
(store (addr "modulo") (define "modulo" (fixedparam ["a""b"]) (prim "modulo" [(ref "a")(ref "b")])))
(store (addr "/") (define "/" (varparam "lst") (apply-prim "/" (ref "lst"))))
(store (addr "=") (define "=" (varparam "lst") (apply-prim "=" (ref "lst"))))
(store (addr ">") (define ">" (varparam "lst") (apply-prim ">" (ref "lst"))))
(store (addr "<") (define "<" (varparam "lst") (apply-prim "<" (ref "lst"))))
(store (addr "<=") (define "<=" (varparam "lst") (apply-prim "<=" (ref "lst"))))
(store (addr ">=") (define ">=" (varparam "lst") (apply-prim ">=" (ref "lst"))))
(store (addr "null?") (define "null?" (fixedparam ["x"]) (prim "null?" [(ref "x")])))
(store (addr "equal?") (define "equal?" (fixedparam ["x""y"]) (prim "equal?" [(ref "x")(ref "y")])))
(store (addr "eq?") (define "eq?" (fixedparam ["x""y"]) (prim "eq?" [(ref "x")(ref "y")])))
(store (addr "cons") (define "cons" (fixedparam ["a""b"]) (prim "cons" [(ref "a")(ref "b")])))
(store (addr "car") (define "car" (fixedparam ["lst"]) (prim "car" [(ref "lst")])))
(store (addr "abs") (define "abs" (fixedparam ["x"]) (prim "abs" [(ref "x")])))
(store (addr "cdr") (define "cdr" (fixedparam ["lst"]) (prim "cdr" [(ref "lst")])))
(store (addr "even?") (define "even?" (fixedparam ["x"]) (app (ref "equal?") [(quote (int "0"))(app (ref "modulo") [(ref "x")(quote (int "2"))])])))
(store (addr "odd?") (define "odd?" (fixedparam ["x"]) (app (ref "equal?") [(quote (int "1"))(app (ref "modulo") [(ref "x")(quote (int "2"))])])))
(store (addr "list") (define "list" (varparam "x") (ref "x")))
(store (addr "float->int") (define "float->int" (fixedparam ["val"]) (prim "inexact->exact" [(ref "val")])))
(store (addr "int->float") (define "int->float" (fixedparam ["val"]) (prim "exact->inexact" [(ref "val")])))
(store (addr "member?") (define "member?" (fixedparam ["x""lst"]) (if (app (ref "null?") [(ref "lst")]) (quote (bool "f")) (if (app (ref "equal?") [(app (ref "car") [(ref "lst")])(ref "x")]) (quote (bool "t")) (app (ref "member?") [(ref "x")(app (ref "cdr") [(ref "lst")])])))))
(store (addr "foldl") (define "foldl" (fixedparam ["fun""acc""lst"]) (if (app (ref "null?") [(ref "lst")]) (ref "acc") (app (ref "foldl") [(ref "fun")(app (ref "fun") [(app (ref "car") [(ref "lst")])(ref "acc")])(app (ref "cdr") [(ref "lst")])]))))
(store (addr "reverse-helper") (define "reverse-helper" (fixedparam ["lst""lst2"]) (if (app (ref "null?") [(ref "lst")]) (ref "lst2") (app (ref "reverse-helper") [(app (ref "cdr") [(ref "lst")])(app (ref "cons") [(app (ref "car") [(ref "lst")])(ref "lst2")])]))))
(store (addr "reverse") (define "reverse" (fixedparam ["lst"]) (app (ref "reverse-helper") [(ref "lst")(app (ref "list") [])])))
(store (addr "take-helper") (define "take-helper" (fixedparam ["lst""n""lst2"]) (if (app (ref "=") [(ref "n")(quote (int "0"))]) (app (ref "reverse") [(ref "lst2")]) (app (ref "take-helper") [(app (ref "cdr") [(ref "lst")])(app (ref "-") [(ref "n")(quote (int "1"))])(app (ref "cons") [(app (ref "car") [(ref "lst")])(ref "lst2")])]))))
(store (addr "take") (define "take" (fixedparam ["lst""n"]) (app (ref "take-helper") [(ref "lst")(ref "n")(app (ref "list") [])])))
(store (addr "length") (define "length" (fixedparam ["lst"]) (if (app (ref "null?") [(ref "lst")]) (quote (int "0")) (app (ref "+") [(quote (int "1"))(app (ref "length") [(app (ref "cdr") [(ref "lst")])])]))))
(store (addr "map") (define "map" (fixedparam ["proc""lst"]) (if (app (ref "null?") [(ref "lst")]) (app (ref "list") []) (app (ref "cons") [(app (ref "proc") [(app (ref "car") [(ref "lst")])])(app (ref "map") [(ref "proc")(app (ref "cdr") [(ref "lst")])])]))))
(store (addr "filter") (define "filter" (fixedparam ["op""lst"]) (if (app (ref "null?") [(ref "lst")]) (app (ref "list") []) (if (app (ref "op") [(app (ref "car") [(ref "lst")])]) (app (ref "cons") [(app (ref "car") [(ref "lst")])(app (ref "filter") [(ref "op")(app (ref "cdr") [(ref "lst")])])]) (app (ref "filter") [(ref "op")(app (ref "cdr") [(ref "lst")])])))))
(store (addr "drop") (define "drop" (fixedparam ["lst""n"]) (if (app (ref "=") [(ref "n")(quote (int "0"))]) (ref "lst") (app (ref "drop") [(app (ref "cdr") [(ref "lst")])(app (ref "-") [(ref "n")(quote (int "1"))])]))))
(store (addr "foldr") (define "foldr" (fixedparam ["proc""acc""lst"]) (if (app (ref "null?") [(ref "lst")]) (ref "acc") (app (ref "proc") [(app (ref "car") [(ref "lst")])(app (ref "foldr") [(ref "proc")(ref "acc")(app (ref "cdr") [(ref "lst")])])]))))
(store (addr "append") (define "append" (fixedparam ["lst1""lst2"]) (if (app (ref "null?") [(ref "lst1")]) (ref "lst2") (app (ref "cons") [(app (ref "car") [(ref "lst1")])(app (ref "append") [(app (ref "cdr") [(ref "lst1")])(ref "lst2")])]))))
(store (addr "hash") (define "hash" (varparam "lst") (apply-prim "hash" (ref "lst"))))
(store (addr "hash-ref") (define "hash-ref" (fixedparam ["h""k"]) (prim "hash-ref" [(ref "h")(ref "k")])))
(store (addr "hash-set") (define "hash-set" (fixedparam ["h""k""v"]) (prim "hash-set" [(ref "h")(ref "k")(ref "v")])))
(store (addr "hash-has-key?") (define "hash-has-key?" (fixedparam ["h""k"]) (prim "hash-has-key?" [(ref "h")(ref "k")])))
(store (addr "hash-count") (define "hash-count" (fixedparam ["h"]) (prim "hash-count" [(ref "h")])))
(store (addr "set") (define "set" (varparam "lst") (apply-prim "set" (ref "lst"))))
(store (addr "set-member?") (define "set-member?" (fixedparam ["s""val"]) (prim "set-member?" [(ref "s")(ref "val")])))
(store (addr "set-add") (define "set-add" (fixedparam ["s""val"]) (prim "set-add" [(ref "s")(ref "val")])))
(store (addr "set-remove") (define "set-remove" (fixedparam ["s""val"]) (prim "set-remove" [(ref "s")(ref "val")])))
(store (addr "set-count") (define "set-count" (fixedparam ["s""val"]) (prim "set-count" [(ref "s")(ref "val")])))
(store (addr "string?") (define "string?" (fixedparam ["str"]) (prim "string?" [(ref "str")])))
(store (addr "string-length") (define "string-length" (fixedparam ["str"]) (prim "string-length" [(ref "str")])))
(store (addr "string-ref") (define "string-ref" (fixedparam ["str""pos"]) (prim "string-ref" [(ref "str")(ref "pos")])))
(store (addr "substring") (define "substring" (fixedparam ["str""start""end"]) (prim "substring" [(ref "str")(ref "start")(ref "end")])))
(store (addr "string-append") (define "string-append" (fixedparam ["s1""s2"]) (prim "string-append" [(ref "s1")(ref "s2")])))
(store (addr "string->list") (define "string->list" (fixedparam ["str"]) (prim "string->list" [(ref "str")])))
(store (addr "call") (define "call" (fixedparam []) (if (quote (bool "f")) (quote (int "1")) (quote (int "2")))))
(store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [])))
(top-level-env (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")) "string->list" (addr "string->list")) "string-append" (addr "string-append")) "substring" (addr "substring")) "string-ref" (addr "string-ref")) "string-length" (addr "string-length")) "string?" (addr "string?")) "set-count" (addr "set-count")) "set-remove" (addr "set-remove")) "set-add" (addr "set-add")) "set-member?" (addr "set-member?")) "set" (addr "set")) "hash-count" (addr "hash-count")) "hash-has-key?" (addr "hash-has-key?")) "hash-set" (addr "hash-set")) "hash-ref" (addr "hash-ref")) "hash" (addr "hash")) "append" (addr "append")) "foldr" (addr "foldr")) "drop" (addr "drop")) "filter" (addr "filter")) "map" (addr "map")) "length" (addr "length")) "take" (addr "take")) "take-helper" (addr "take-helper")) "reverse" (addr "reverse")) "reverse-helper" (addr "reverse-helper")) "foldl" (addr "foldl")) "member?" (addr "member?")) "int->float" (addr "int->float")) "float->int" (addr "float->int")) "list" (addr "list")) "odd?" (addr "odd?")) "even?" (addr "even?")) "cdr" (addr "cdr")) "abs" (addr "abs")) "car" (addr "car")) "cons" (addr "cons")) "eq?" (addr "eq?")) "equal?" (addr "equal?")) "null?" (addr "null?")) ">=" (addr ">=")) "<=" (addr "<=")) "<" (addr "<")) ">" (addr ">")) "=" (addr "=")) "/" (addr "/")) "modulo" (addr "modulo")) "*" (addr "*")) "-" (addr "-")) "max" (addr "max")) "+" (addr "+")))